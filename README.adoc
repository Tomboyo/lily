= Lily OAS-To-Java Compiler

Lily is a compiler that consumes OpenAPI (Swagger) specifications and produces Java source code.
It is intended to be an alternative to https://github.com/OpenAPITools/openapi-generator[OpenAPI Generator], which at time of writing is the only option, and substantially more complete than Lily.

== Goals

. Generate java source code directly from an OAS document within a java build pipeline (e.g. integrated with Maven or Gradle).
. Support OAS v3.
. Target Java 17.
. Help end-users work around incorrect or incomplete schema specifications so that they can make progress while awaiting upstream fixes.
. [Tentative] Support customizable generated code, especially code which can leverage user-made JARs from unrelated projects.

== Non-Goals

. Do not (yet) support other languages than Java.
It's not clear that a Java-oriented AST will cleanly translate to another language target.
. Do not support too many options.
Options become confusing to maintain -- prefer opinionated code that works for most people who are doing sensible things.
. Do not support generate-and-check-in workflows.
Treat the OAS document as source code.

== Plan

Our goal is to create a library that users could reasonably download and use as soon as possible. The library will do very little, but each release will add incremental value to the library. The rough steps along out path are as follows:

. First, establish helper functions in the lily-http project that users can use to simplify using the java.net.http library along with Jackson. For example, this includes RFC6570 parameter encoding (e.g. exploded form style parameter encoding for query parameters) and Jackson-integrated body publishers and body handlers for sending and receiving http requests.

. Next, generate a fluent API from the user's OAS which exposes HttpRequest.Builder factories for each OAS operation. These factories initially do nothing other than instantiate HttpRequest.Builder instances. The api looks something like the following:
+
[source,java]
----
var myService = MyService.builder()
  .httpClient(createMyHttpClient())
  .build();
HttpRequestBuilder request = myService
  .allOperations()
  .createBlogPost()
  .request(); // == HttpRequest.builder().build();
myService.client() // the java.net.http client myService was built with
  .send(request);
----

. From here, successively add features to the API, such as fluent parameter arguments, generated request/response objects, and so on. The API might evolve over time to look like this:
+
[source,java]
----
myService
  .blogOperations() // operations with the "blog" tag in the OAS
  .createBlogPost()
  .author(...)
  .writtenOn(...)
  .contents(new BlogPost(...))
  .send() // returns a HttpResponse<CreateBlogPostResponse> object
----

== Design

Lily is a layered API with "high-level" layers that orchestrate full requests using generated code and "low-level" layers that help the developer implement requests from scratch if necessary. High-level layers always allow the developer to move into lower-levels so that the developer can override Lily to work around flaws in Lily, the upstream OAS, or other environmental issues. For example, a user might write code like the following:

[source,java]
----
var request = myService
  .blogOperations()
  .createBlogPost()
  .author(...)
  .writtenOn(...)
  .content(...)
  // Dip into the java.net.http API to work around OAS or Lily limitations
  .request(builder -> builder // java.net.http.HttpRequest.Builder
        .header("MissingFromTheOas", "Foo")
        .header("NotSupportedByLilyYet", "Bar"))
  .sendAsync();
----

Lily helps the developer where it is able, but gets out of the way when requested. With Lily, simple things are _easy_, and complex things are _possible_.

== Quick Tour

Lily is composed of four modules in the `modules` directory:

- `it-project` is an integration test project and living example of the compiler in action. The pom shows how to configure Lily in a maven build. The OAS shows what Lily supports. Test cases demonstrate where Lily lends support to HTTP clients. Check out the generated-sources directory under `target/` to see how it compiles OAS definitions.

- `lily-compiler-maven-plugin` is a teensy-weensy Maven plugin that reads configuration from the pom and hands it off to the compiler project.

- `lily-compiler` is responsible for reading an OAS document, translating it to an intermediary AST (abstract syntax tree), rendering the AST as source code, and finally saving source code to disc.

- `lily-http` defines classes to help use the java.net.http API. For example, this contains the JacksonBodyPublisher and JacksonBodyHandler for sending and receiving Json-serialized content.